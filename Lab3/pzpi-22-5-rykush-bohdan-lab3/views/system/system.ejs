<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–æ–Ω—Ç–∞–∫—Ç–∏ - EcoGuard</title>
    <link rel="stylesheet" href="/style/partials/footer_header.css">
    <link rel="stylesheet" href="/style/system/system.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* –ê–Ω—ñ–º–∞—Ü—ñ—è –¥–ª—è –º–∞—Ä–∫–µ—Ä–∞ –Ω–∞ –∫–∞—Ä—Ç—ñ */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(2); opacity: 0; }
        }
        .pulse {
            border-radius: 50%;
            border: 2px solid #3498db;
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
     <%- include('../partials/header') %>

<main class="system-main" data-user='<%- JSON.stringify(user) %>'> 
    
        <div class="system-grid">
            <div class="widget welcome-widget">
                <h1>–í—ñ—Ç–∞—î–º–æ, <%= user.name %>!</h1>
                <p>–û—Å—å –ø–æ—Ç–æ—á–Ω–∏–π –µ–∫–æ–ª–æ–≥—ñ—á–Ω–∏–π —Å—Ç–∞–Ω –≤–∞—à–æ–≥–æ —Ä–µ–≥—ñ–æ–Ω—É.</p>
            </div>
            <div class="widget nearest-sensor-widget">
                <h3>–ù–∞–π–±–ª–∏–∂—á–∏–π –¥–∞—Ç—á–∏–∫</h3>
                <div id="nearest-sensor-info"><p>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...</p></div>
            </div>
            <div class="widget recommendations-widget">
                <h3>–ü–æ—Ä–∞–¥–∏ –¥–ª—è –≤–∞—Å</h3>
                <div id="recommendations-info"><p>–ê–Ω–∞–ª—ñ–∑—É—î–º–æ –¥–∞–Ω—ñ...</p></div>
            </div>
            <div class="widget map-widget">
                <h3>–ö–∞—Ä—Ç–∞ –¥–∞—Ç—á–∏–∫—ñ–≤</h3>
                <div id="mini-map"></div>
                <a href="/map" class="map-link">–ü–µ—Ä–µ–π—Ç–∏ –¥–æ –ø–æ–≤–Ω–æ—ó –∫–∞—Ä—Ç–∏ ‚Üí</a>
            </div>

            <div class="widget stats-widget">
                <h3>–ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–∞—Ç—á–∏–∫–∞—Ö</h3>
                <div class="chart-groups-container">
                    
                    <div class="chart-group">
                        <h4>–Ø–∫—ñ—Å—Ç—å –ø–æ–≤—ñ—Ç—Ä—è</h4>
                        <div class="chart-item">
                            <canvas id="co2Chart"></canvas>
                        </div>
                        <div class="chart-item">
                            <canvas id="pm25Chart"></canvas>
                        </div>
                         <div class="chart-item">
                            <canvas id="so2Chart"></canvas>
                        </div>
                    </div>

                    <div class="chart-group">
                        <h4>–Ø–∫—ñ—Å—Ç—å –≤–æ–¥–∏</h4>
                        <div class="chart-item">
                            <canvas id="tempChart"></canvas>
                        </div>
                        <div class="chart-item">
                            <canvas id="acidityChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-group">
                        <h4>–†—ñ–≤–µ–Ω—å —à—É–º—É</h4>
                        <div class="chart-item">
                            <canvas id="noiseChart"></canvas>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </main>

      <%- include('../partials/footer') %>

    <script src="/js/system/system.js" defer></script>
    <script src="/js/partials/footer.js" defer></script>
      <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
       document.addEventListener('DOMContentLoaded', async () => {
    // –ï–ª–µ–º–µ–Ω—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫–∏ —Ç–∞ –±–∞–∑–æ–≤—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è (–±–µ–∑ –∑–º—ñ–Ω)
    const nearestSensorInfo = document.getElementById('nearest-sensor-info');
    const recommendationsInfo = document.getElementById('recommendations-info');
    const miniMapElement = document.getElementById('mini-map');
    const mainElement = document.querySelector('.system-main');
    const user = JSON.parse(mainElement.dataset.user);
    let allSensors = [];
    let map;
    let charts = {};

    // –£—Ç–∏–ª—ñ—Ç–∏ –¥–ª—è –∫–∞—Ä—Ç–∏, –≤—ñ–¥—Å—Ç–∞–Ω—ñ, —ñ–∫–æ–Ω–æ–∫ (–±–µ–∑ –∑–º—ñ–Ω)
    const createIcon = (color) => new L.Icon({ iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`, shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
    const greenIcon = createIcon('green'), yellowIcon = createIcon('gold'), redIcon = createIcon('red'), greyIcon = createIcon('grey');
    const getIconByStatus = (status) => { const s = status ? status.toLowerCase() : 'unknown'; if (s === 'good' || s === '–¥–æ–±—Ä–µ') return greenIcon; if (s === 'moderate' || s === '–ø–æ–º—ñ—Ä–Ω–æ') return yellowIcon; if (s === 'poor' || s === '–ø–æ–≥–∞–Ω–æ') return redIcon; return greyIcon; };
    function getDistance(lat1, lon1, lat2, lon2) { const R = 6371; const dLat = (lat2 - lat1) * Math.PI / 180; const dLon = (lon2 - lon1) * Math.PI / 180; const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; };
    // –Ü–Ω—à—ñ —Ñ—É–Ω–∫—Ü—ñ—ó (getRecommendations, updateUI, processDataForLocation, saveLocation) –∑–∞–ª–∏—à–∞—é—Ç—å—Å—è –±–µ–∑ –∑–º—ñ–Ω...
    function getRecommendations(sensor) { if (!sensor || !sensor.status) return "<p>–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö.</p>"; let advice = "<ul>"; const status = sensor.status.toLowerCase(); switch(sensor.sensor_type.toLowerCase()){ case 'air': if(status === 'good' || status === '–¥–æ–±—Ä–µ') advice += "<li>–Ø–∫—ñ—Å—Ç—å –ø–æ–≤—ñ—Ç—Ä—è —á—É–¥–æ–≤–∞.</li>"; else if (status === 'moderate' || status === '–ø–æ–º—ñ—Ä–Ω–æ') advice += "<li>–Ø–∫—ñ—Å—Ç—å –ø–æ–≤—ñ—Ç—Ä—è –ø–æ—Å–µ—Ä–µ–¥–Ω—è.</li>"; else advice += "<li>–ü–æ–≥–∞–Ω–∞ —è–∫—ñ—Å—Ç—å –ø–æ–≤—ñ—Ç—Ä—è.</li>"; break; case 'water': if(status === 'good' || status === '–¥–æ–±—Ä–µ') advice += "<li>–Ø–∫—ñ—Å—Ç—å –≤–æ–¥–∏ –≤ –Ω–æ—Ä–º—ñ.</li>"; else advice += "<li>–Ø–∫—ñ—Å—Ç—å –≤–æ–¥–∏ –ø–æ–≥–∞–Ω–∞.</li>"; break; case 'noise': if(status === 'good' || status === '–¥–æ–±—Ä–µ') advice += "<li>–†—ñ–≤–µ–Ω—å —à—É–º—É –Ω–∏–∑—å–∫–∏–π.</li>"; else advice += "<li>–†—ñ–≤–µ–Ω—å —à—É–º—É –≤–∏—Å–æ–∫–∏–π.</li>"; break; } advice += "</ul>"; return advice; }
    function updateUI(nearest) { let sensorHtml = `<h4>${nearest.sensor_name}</h4><p><strong>–¢–∏–ø:</strong> ${nearest.sensor_type}</p><p><strong>–°—Ç–∞—Ç—É—Å:</strong> <span class="status-${(nearest.status || 'unknown').toLowerCase()}">${nearest.status || '–ù–µ–≤—ñ–¥–æ–º–æ'}</span></p>`; if (nearest.data_values) for (const [key, value] of Object.entries(nearest.data_values)) sensorHtml += `<p><strong>${key.charAt(0).toUpperCase() + key.slice(1)}:</strong> ${value}</p>`; sensorHtml += `<p><small>–û–Ω–æ–≤–ª–µ–Ω–æ: ${new Date(nearest.last_updated).toLocaleString('uk-UA')}</small></p>`; nearestSensorInfo.innerHTML = sensorHtml; recommendationsInfo.innerHTML = getRecommendations(nearest); if (!map) { map = L.map(miniMapElement).setView([nearest.latitude, nearest.longitude], 13); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map); allSensors.forEach(s => L.marker([s.latitude, s.longitude], { icon: getIconByStatus(s.status) }).addTo(map).bindPopup(`<b>${s.sensor_name}</b>`)); const pulseIcon = L.divIcon({className: 'pulse', iconSize: [20, 20]}); L.marker([nearest.latitude, nearest.longitude], {icon: pulseIcon}).addTo(map); } else { map.setView([nearest.latitude, nearest.longitude], 13); } }
    function processDataForLocation(latitude, longitude) { let nearestSensor = null; let minDistance = Infinity; allSensors.forEach(sensor => { const distance = getDistance(latitude, longitude, sensor.latitude, sensor.longitude); if (distance < minDistance) { minDistance = distance; nearestSensor = sensor; } }); if (nearestSensor) { updateUI(nearestSensor); } else { nearestSensorInfo.innerHTML = '<p>–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –Ω–∞–π–±–ª–∏–∂—á–∏–π –¥–∞—Ç—á–∏–∫.</p>'; } }
    async function saveLocation(latitude, longitude) { try { await fetch('/api/update-location', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ latitude, longitude }) }); } catch (error) { console.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–±–µ—Ä–µ–≥—Ç–∏ –º—ñ—Å—Ü–µ–∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è:", error); } }

    // üî• **–û–ù–û–í–õ–ï–ù–ê –§–£–ù–ö–¶–Ü–Ø –î–õ–Ø –°–¢–í–û–†–ï–ù–ù–Ø –ì–†–ê–§–Ü–ö–Ü–í**
    // –¶–µ–π –∫–æ–¥ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Ç–µ–≥—É <script> –≤ —Ñ–∞–π–ª—ñ system.ejs

function updateCharts(sensors) {
    const createChart = (canvasId, data, options) => {
        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx) return;
        if (charts[canvasId]) charts[canvasId].destroy();
        
        charts[canvasId] = new Chart(ctx, {
            type: 'bar',
            data: data,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: options.title }
                },
                scales: {
                    x: {
                        ticks: {
                            callback: function(value) { return value + (options.unit || '') }
                        }
                    }
                }
            }
        });
    };

    const airSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'air' && s.data_values);
    const waterSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'water' && s.data_values);
    const noiseSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'noise' && s.data_values);

    if (airSensors.length > 0) {
        createChart('co2Chart', {
            labels: airSensors.map(s => s.sensor_name),
            datasets: [{ data: airSensors.map(s => s.data_values.co2 || 0), backgroundColor: '#ff6384' }]
        }, { title: '–†—ñ–≤–µ–Ω—å CO‚ÇÇ (ppm)', unit: ' ppm' });
        
        createChart('pm25Chart', {
            labels: airSensors.map(s => s.sensor_name),
            datasets: [{ data: airSensors.map(s => s.data_values.pm25 || 0), backgroundColor: '#36a2eb' }]
        }, { title: '–ß–∞—Å—Ç–∏–Ω–∫–∏ PM2.5 (¬µg/m¬≥)', unit: ' ¬µg/m¬≥' });
        
        createChart('so2Chart', {
            labels: airSensors.map(s => s.sensor_name),
            datasets: [{ data: airSensors.map(s => s.data_values.so2 || 0), backgroundColor: '#cc65fe' }]
        }, { title: '–†—ñ–≤–µ–Ω—å SO‚ÇÇ (¬µg/m¬≥)', unit: ' ¬µg/m¬≥' });
    }

    if (waterSensors.length > 0) {
        createChart('tempChart', {
            labels: waterSensors.map(s => s.sensor_name),
            datasets: [{ data: waterSensors.map(s => s.data_values.temperature || 0), backgroundColor: '#4bc0c0' }]
        }, { title: '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –≤–æ–¥–∏ (¬∞C)', unit: '¬∞C' });

        createChart('acidityChart', {
            labels: waterSensors.map(s => s.sensor_name),
            // üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: 'acidity' –∑–º—ñ–Ω–µ–Ω–æ –Ω–∞ 'ph'
            datasets: [{ data: waterSensors.map(s => s.data_values.ph || 0), backgroundColor: '#ff9f40' }]
        }, { title: '–ö–∏—Å–ª–æ—Ç–Ω—ñ—Å—Ç—å (pH)', unit: ' pH' });
    }

    if (noiseSensors.length > 0) {
        createChart('noiseChart', {
            labels: noiseSensors.map(s => s.sensor_name),
            // üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: 'level' –∑–º—ñ–Ω–µ–Ω–æ –Ω–∞ 'db_level'
            datasets: [{ data: noiseSensors.map(s => s.data_values.db_level || 0), backgroundColor: '#ffcd56' }]
        }, { title: '–†—ñ–≤–µ–Ω—å —à—É–º—É (dB)', unit: ' dB' });
    }
}

    // –û—Å–Ω–æ–≤–Ω–∏–π –ø–æ—Ç—ñ–∫ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è (–±–µ–∑ –∑–º—ñ–Ω)
    try {
        const response = await fetch('/api/sensors-with-latest-readings');
        allSensors = await response.json();
        if (!allSensors || allSensors.length === 0) {
            nearestSensorInfo.innerHTML = '<p>–ê–∫—Ç–∏–≤–Ω—ñ –¥–∞—Ç—á–∏–∫–∏ –≤—ñ–¥—Å—É—Ç–Ω—ñ.</p>';
            return;
        }
        updateCharts(allSensors);

        if (user.latitude && user.longitude) {
            nearestSensorInfo.innerHTML = '<p>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω–µ –º—ñ—Å—Ü–µ–∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è...</p>';
            processDataForLocation(user.latitude, user.longitude);
        } else {
            nearestSensorInfo.innerHTML = '<p>–í–∏–∑–Ω–∞—á–∞—î–º–æ –≤–∞—à–µ –º—ñ—Å—Ü–µ–∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –≤–ø–µ—Ä—à–µ...</p>';
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    processDataForLocation(latitude, longitude);
                    saveLocation(latitude, longitude);
                },
                (error) => {
                    console.error("–ü–æ–º–∏–ª–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—ó:", error);
                    nearestSensorInfo.innerHTML = '<p>–ù–µ –≤–¥–∞–ª–æ—Å—è –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –ª–æ–∫–∞—Ü—ñ—é. –ü–æ–∫–∞–∑—É—î–º–æ –¥–∞–Ω—ñ –¥–ª—è –ø–µ—Ä—à–æ–≥–æ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –¥–∞—Ç—á–∏–∫–∞.</p>';
                    updateUI(allSensors[0]);
                }
            );
        }
    } catch (error) {
        console.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö:", error);
        nearestSensorInfo.innerHTML = '<p>–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑ —Å–µ—Ä–≤–µ—Ä–∞.</p>';
    }
});
</script>
    </script>
</body>
</html>
