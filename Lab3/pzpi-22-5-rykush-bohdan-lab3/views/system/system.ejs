<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–∏—Å—Ç–µ–º–∞ - EcoGuard</title>
    <link rel="stylesheet" href="/style/partials/footer_header.css">
    <link rel="stylesheet" href="/style/system/system.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        /* –ê–Ω—ñ–º–∞—Ü—ñ—è –¥–ª—è –º–∞—Ä–∫–µ—Ä–∞ –Ω–∞ –∫–∞—Ä—Ç—ñ */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
            100% { transform: scale(2); opacity: 0; }
        }
        .pulse {
            border-radius: 50%;
            border: 2px solid #3498db;
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <%- include('../partials/header') %>

    <main class="system-main" data-user='<%- JSON.stringify(user) %>'>
        <div class="system-grid">
            <div class="widget welcome-widget">
                <h1>–í—ñ—Ç–∞—î–º–æ, <%= user.name %>!</h1>
                <p>–û—Å—å –ø–æ—Ç–æ—á–Ω–∏–π –µ–∫–æ–ª–æ–≥—ñ—á–Ω–∏–π —Å—Ç–∞–Ω –≤–∞—à–æ–≥–æ —Ä–µ–≥—ñ–æ–Ω—É.</p>
            </div>
            <div class="widget nearest-sensor-widget">
                <h3>–ù–∞–π–±–ª–∏–∂—á–∏–π –¥–∞—Ç—á–∏–∫</h3>
                <div id="nearest-sensor-info"><p>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...</p></div>
            </div>
            <div class="widget history-widget">
                <h3>–Ü—Å—Ç–æ—Ä—ñ—è (24 –≥–æ–¥)</h3>
                <div class="history-controls" id="historyControls"></div>
                <div class="chart-item">
                    <canvas id="historyChart"></canvas>
                </div>
            </div>
            <div class="widget map-widget">
                <h3>–ö–∞—Ä—Ç–∞ –¥–∞—Ç—á–∏–∫—ñ–≤</h3>
                <div id="mini-map"></div>
                <a href="/map" class="map-link">–ü–µ—Ä–µ–π—Ç–∏ –¥–æ –ø–æ–≤–Ω–æ—ó –∫–∞—Ä—Ç–∏ ‚Üí</a>
            </div>
            <div class="widget leaderboard-widget">
                <h3>–ï–∫–æ–ª–æ–≥—ñ—á–Ω–∏–π —Ä–µ–π—Ç–∏–Ω–≥</h3>
                <div class="leaderboard-columns">
                    <div class="leaderboard-column">
                        <h4>‚úÖ –ù–∞–π—á–∏—Å—Ç—ñ—à—ñ –∑–æ–Ω–∏</h4>
                        <ul id="best-performers"><li>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</li></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4>‚ö†Ô∏è –ù–∞–π–±—ñ–ª—å—à –∑–∞–±—Ä—É–¥–Ω–µ–Ω—ñ</h4>
                        <ul id="worst-performers"><li>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</li></ul>
                    </div>
                </div>
            </div>
            <div class="widget stats-widget">
                <h3>–ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –¥–∞—Ç—á–∏–∫–∞—Ö</h3>
                <div class="chart-groups-container">
                    <div class="chart-group">
                        <h4>–Ø–∫—ñ—Å—Ç—å –ø–æ–≤—ñ—Ç—Ä—è</h4>
                        <div class="chart-item"><canvas id="co2Chart"></canvas></div>
                        <div class="chart-item"><canvas id="pm25Chart"></canvas></div>
                        <div class="chart-item"><canvas id="so2Chart"></canvas></div>
                    </div>
                    <div class="chart-group">
                        <h4>–Ø–∫—ñ—Å—Ç—å –≤–æ–¥–∏</h4>
                        <div class="chart-item"><canvas id="tempChart"></canvas></div>
                        <div class="chart-item"><canvas id="acidityChart"></canvas></div>
                    </div>
                    <div class="chart-group">
                        <h4>–†—ñ–≤–µ–Ω—å —à—É–º—É</h4>
                        <div class="chart-item"><canvas id="noiseChart"></canvas></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

      <%- include('../partials/footer') %>

    <script src="/js/system/system.js" defer></script>
    <script src="/js/partials/footer.js" defer></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        const mainElement = document.querySelector('.system-main');
        const user = JSON.parse(mainElement.dataset.user);
        const nearestSensorInfo = document.getElementById('nearest-sensor-info');
        const bestPerformersList = document.getElementById('best-performers');
        const worstPerformersList = document.getElementById('worst-performers');
        let allSensors = [];
        let map;
        let charts = {};

        const createIcon = (color) => new L.Icon({ iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`, shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
        const greenIcon = createIcon('green'), yellowIcon = createIcon('gold'), redIcon = createIcon('red'), greyIcon = createIcon('grey');
        const getIconByStatus = (status) => { const s = status ? status.toLowerCase() : 'unknown'; if (s === 'good' || s === '–¥–æ–±—Ä–µ') return greenIcon; if (s === 'moderate' || s === '–ø–æ–º—ñ—Ä–Ω–æ') return yellowIcon; if (s === 'poor' || s === '–ø–æ–≥–∞–Ω–æ') return redIcon; return greyIcon; };
        function getDistance(lat1, lon1, lat2, lon2) { const R = 6371; const dLat = (lat2 - lat1) * Math.PI / 180; const dLon = (lon2 - lon1) * Math.PI / 180; const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; };
        async function saveLocation(latitude, longitude) { try { await fetch('/api/update-location', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ latitude, longitude }) }); } catch (error) { console.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –º—ñ—Å—Ü–µ–∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è:", error); } }

        function updateLeaderboards(sensors) {
            const airSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'air' && s.data_values?.pm25 != null);
            if (airSensors.length < 3) { bestPerformersList.innerHTML = '<li>–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö</li>'; worstPerformersList.innerHTML = '<li>–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–∞–Ω–∏—Ö</li>'; return; };
            const sortedSensors = [...airSensors].sort((a, b) => a.data_values.pm25 - b.data_values.pm25);
            const best = sortedSensors.slice(0, 3);
            const worst = sortedSensors.slice(-3).reverse();
            bestPerformersList.innerHTML = best.map(s => `<li>${s.sensor_name} <span>(${s.data_values.pm25} ¬µg/m¬≥)</span></li>`).join('');
            worstPerformersList.innerHTML = worst.map(s => `<li>${s.sensor_name} <span>(${s.data_values.pm25} ¬µg/m¬≥)</span></li>`).join('');
        }
        
        // üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: –§—É–Ω–∫—Ü—ñ—ó renderHistoryChart —Ç–∞ createHistoryChart —Ç–µ–ø–µ—Ä –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ DOMContentLoaded
        function renderHistoryChart(historyData, metricKey) {
            const data = { labels: historyData.map(d => new Date(d.timestamp)), datasets: [{ label: metricKey.toUpperCase(), data: historyData.map(d => d.data_values ? (d.data_values[metricKey] || null) : null), borderColor: '#3498db', backgroundColor: 'rgba(52, 152, 219, 0.2)', tension: 0.1, fill: true }] };
            const ctx = document.getElementById('historyChart')?.getContext('2d');
            if (!ctx) return;
            if (charts.historyChart) charts.historyChart.destroy();
            charts.historyChart = new Chart(ctx, { type: 'line', data: data, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } } } }, plugins: { legend: { display: false } } } });
        }

        async function createHistoryChart(sensor) {
            const controlsContainer = document.getElementById('historyControls');
            const chartContainer = document.querySelector('#historyChart').parentElement;
            controlsContainer.innerHTML = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...';
            if (!sensor) { controlsContainer.innerHTML = ''; chartContainer.style.display = 'none'; return; }
            try {
                const response = await fetch(`/api/sensors/${sensor.sensor_id}/history`);
                const historyData = await response.json();
                if (historyData.length === 0) { controlsContainer.innerHTML = '–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö –∑–∞ 24 –≥–æ–¥–∏–Ω–∏.'; chartContainer.style.display = 'none'; return; }
                chartContainer.style.display = 'block';
                const availableKeys = Object.keys(historyData[0].data_values).filter(key => historyData.some(d => d.data_values[key] !== null));
                controlsContainer.innerHTML = availableKeys.map(key => `<button data-metric="${key}">${key.toUpperCase()}</button>`).join('');
                controlsContainer.querySelectorAll('button').forEach(button => { button.addEventListener('click', () => { controlsContainer.querySelector('button.active')?.classList.remove('active'); button.classList.add('active'); renderHistoryChart(historyData, button.dataset.metric); }); });
                if (controlsContainer.firstChild) { controlsContainer.firstChild.click(); }
            } catch (error) { console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó:', error); controlsContainer.innerHTML = '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è.'; chartContainer.style.display = 'none'; }
        }
        
        function updateUI(nearest) {
            let sensorHtml = `<h4>${nearest.sensor_name}</h4><p><strong>–¢–∏–ø:</strong> ${nearest.sensor_type}</p><p><strong>–°—Ç–∞—Ç—É—Å:</strong> <span class="status-${(nearest.status || 'unknown').toLowerCase()}">${nearest.status || '–ù–µ–≤—ñ–¥–æ–º–æ'}</span></p>`; if (nearest.data_values) for (const [key, value] of Object.entries(nearest.data_values)) { if(value !== null) sensorHtml += `<p><strong>${key.charAt(0).toUpperCase() + key.slice(1)}:</strong> ${value}</p>`; } sensorHtml += `<p><small>–û–Ω–æ–≤–ª–µ–Ω–æ: ${new Date(nearest.last_updated).toLocaleString('uk-UA')}</small></p>`;
            nearestSensorInfo.innerHTML = sensorHtml;
            if (!map) { map = L.map('mini-map').setView([nearest.latitude, nearest.longitude], 13); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map); allSensors.forEach(s => L.marker([s.latitude, s.longitude], { icon: getIconByStatus(s.status) }).addTo(map).bindPopup(`<b>${s.sensor_name}</b>`)); const pulseIcon = L.divIcon({className: 'pulse', iconSize: [20, 20]}); L.marker([nearest.latitude, nearest.longitude], {icon: pulseIcon}).addTo(map); } else { map.setView([nearest.latitude, nearest.longitude], 13); }
            createHistoryChart(nearest);
        }
        
        function updateCharts(sensors) {
            const createChart = (canvasId, data, options) => {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                if (charts[canvasId]) charts[canvasId].destroy();
                charts[canvasId] = new Chart(ctx, { type: 'bar', data: data, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, title: { display: true, text: options.title } }, scales: { x: { ticks: { callback: function(value) { return value + (options.unit || '') } } } } } });
            };
            const airSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'air' && s.data_values);
            const waterSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'water' && s.data_values);
            const noiseSensors = sensors.filter(s => s.sensor_type.toLowerCase() === 'noise' && s.data_values);
            if (airSensors.length > 0) { createChart('co2Chart', { labels: airSensors.map(s => s.sensor_name), datasets: [{ data: airSensors.map(s => s.data_values.co2 || 0), backgroundColor: '#ff6384' }] }, { title: '–†—ñ–≤–µ–Ω—å CO‚ÇÇ (ppm)', unit: ' ppm' }); createChart('pm25Chart', { labels: airSensors.map(s => s.sensor_name), datasets: [{ data: airSensors.map(s => s.data_values.pm25 || 0), backgroundColor: '#36a2eb' }] }, { title: '–ß–∞—Å—Ç–∏–Ω–∫–∏ PM2.5 (¬µg/m¬≥)', unit: ' ¬µg/m¬≥' }); createChart('so2Chart', { labels: airSensors.map(s => s.sensor_name), datasets: [{ data: airSensors.map(s => s.data_values.so2 || 0), backgroundColor: '#cc65fe' }] }, { title: '–†—ñ–≤–µ–Ω—å SO‚ÇÇ (¬µg/m¬≥)', unit: ' ¬µg/m¬≥' }); }
            if (waterSensors.length > 0) { createChart('tempChart', { labels: waterSensors.map(s => s.sensor_name), datasets: [{ data: waterSensors.map(s => s.data_values.temperature || 0), backgroundColor: '#4bc0c0' }] }, { title: '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –≤–æ–¥–∏ (¬∞C)', unit: '¬∞C' }); createChart('acidityChart', { labels: waterSensors.map(s => s.sensor_name), datasets: [{ data: waterSensors.map(s => s.data_values.ph || 0), backgroundColor: '#ff9f40' }] }, { title: '–ö–∏—Å–ª–æ—Ç–Ω—ñ—Å—Ç—å (pH)', unit: ' pH' }); }
            if (noiseSensors.length > 0) { createChart('noiseChart', { labels: noiseSensors.map(s => s.sensor_name), datasets: [{ data: noiseSensors.map(s => s.data_values.db_level || 0), backgroundColor: '#ffcd56' }] }, { title: '–†—ñ–≤–µ–Ω—å —à—É–º—É (dB)', unit: ' dB' }); }
        }

        async function main() {
            try {
                const response = await fetch('/api/sensors-with-latest-readings');
                allSensors = await response.json();
                if (!allSensors || allSensors.length === 0) { document.body.innerHTML = "<h1>–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ–Ω—Å–æ—Ä—ñ–≤.</h1>"; return; }
                updateCharts(allSensors);
                updateLeaderboards(allSensors);
                if (user.latitude && user.longitude) { processDataForLocation(user.latitude, user.longitude); } else { navigator.geolocation.getCurrentPosition( (position) => { const { latitude, longitude } = position.coords; processDataForLocation(latitude, longitude); saveLocation(latitude, longitude); }, (error) => { console.error("–ü–æ–º–∏–ª–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—ó:", error); updateUI(allSensors[0]); } ); }
            } catch (error) { console.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö:", error); }
        }
        
        function processDataForLocation(latitude, longitude) {
            let nearestSensor = null; let minDistance = Infinity;
            allSensors.forEach(sensor => { const distance = getDistance(latitude, longitude, sensor.latitude, sensor.longitude); if (distance < minDistance) { minDistance = distance; nearestSensor = sensor; } });
            if (nearestSensor) { updateUI(nearestSensor); } else { updateUI(allSensors[0]); }
        }

        main();
    });
    </script>
</body>
</html>
