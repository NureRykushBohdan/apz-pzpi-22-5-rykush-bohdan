ЗВІТ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмної інженерії»

ЗВІТ

З практичної роботи №1

з дисципліни “Архітектура програмного забезпечення”

на тему «Патерни проєктування»

Виконав: ст. гр. ПЗПІ-22-5, Рикуш Богдан

Перевірив: ст. викл. кафедри ПІ, Сокорчук І. П.

ХАРКІВ 2025

---

ІСТОРІЯ ЗМІН

| № | Дата | Версія звіту | Опис змін та виправлень |
| :--- | :--- | :--- | :--- |
| 1 | 07.06.2025 | 1.0 | Створено звіт з усіма розділами та додатками |

---

ЗАВДАННЯ

У межах даної роботи необхідно обрати один із патернів проєктування (крім Singleton) та детально вивчити його призначення, принципи роботи та сфери застосування. Підготувати презентацію, яка міститиме теоретичний опис патерна та реальні приклади використання.

---

ОПИС ВИКОНАНОЇ РОБОТИ

У межах даної роботи було обрано патерн «Adapter» (Адаптер), який належить до групи структурних патернів проєктування. Його головне призначення — забезпечити сумісність між об'єктами з несумісними інтерфейсами. Патерн виступає в ролі "перехідника" між двома різними інтерфейсами, дозволяючи їм працювати разом без зміни їхнього вихідного коду.

Патерн "Adapter" особливо корисний при інтеграції існуючих (legacy) систем з новими, або при роботі зі сторонніми бібліотеками, API яких не відповідає інтерфейсу, що очікується клієнтським кодом.

Для демонстрації роботи патерна було розроблено програмний код на мові Java. Було реалізовано цільовий інтерфейс `Printer`, клас, що адаптується `OldPrinter` з несумісним методом, та клас `PrinterAdapter`, який поєднує їх. Це дозволило клієнтському коду працювати з уніфікованим інтерфейсом `Printer`, не залежачи від конкретної реалізації.

Таким чином, у ході виконання роботи було детально досліджено патерн "Adapter" та продемонстровано його практичне застосування у програмному коді.

---

ВИСНОВКИ

У ході виконання цієї практичної роботи було детально вивчено патерн "Adapter", його призначення, структуру та принципи роботи. Було проаналізовано його роль у підвищенні гнучкості та модульності програмних систем.

Основні переваги патерна "Adapter", виявлені в ході роботи:
1.  Повторне використання коду: Дозволяє інтегрувати існуючі класи в нові системи без модифікації їхнього коду.
2.  Зменшення залежностей: Клієнтський код працює з цільовим інтерфейсом і не залежить від конкретних класів, що адаптуються.
3.  Підвищення гнучкості: Спрощує заміну одного зовнішнього компонента іншим з відмінним API.

Завдяки виконанню цієї роботи вдалося поглибити знання про структурні патерни проєктування та на практиці застосувати їх для вирішення реальних завдань інтеграції компонентів у програмуванні.





ДОДАТОК А  

Посилання на відеозапис доповіді та текст хронологічного опису доповіді  

Відеозапис доповіді на YouTube: https://youtu.be/LPBvs79ll0c

Хронологічний опис відео:  

00:00 - Вступ
00:08 - Що таке патерн Adapter?
00:20 - Призначення патерну
00:42 - Структура патерну
00:50 - Типи адаптерів
01:15 - Код без адаптера (Java)
01:32 - Застосування Adapter (Java)
01:50 - Переваги після адаптера
02:08 -  Практичне застосування
02:24 - Висновки
02:42 - Кінець



ДОДАТОК Б 


Слайд 1: Титульний
 Патерн Adapter в архітектурі програмного забезпечення
 Виконав: студ. гр. ПЗПІ-22-5, Рикуш Богдан

Слайд 2: Що таке патерн Adapter?
 Структурний патерн проєктування.
 Дозволяє об’єктам з несумісними інтерфейсами працювати разом.
 Використовується для адаптації одного інтерфейсу до іншого, виступаючи в ролі "перехідника".
 Застосовується для інтеграції старих систем з новими.

Слайд 3: Призначення патерну
 Забезпечує сумісність між класами з різними інтерфейсами.
 Дозволяє повторно використовувати існуючий код без його модифікації.
 Зменшує залежність між компонентами системи.

Слайд 4: Структура патерну
 Target: Інтерфейс, який очікує клієнт.
 Adaptee: Клас з несумісним інтерфейсом, який потрібно адаптувати.
 Adapter: Клас, що реалізує інтерфейс `Target` і "огортає" об'єкт `Adaptee`.
 Client: Код, який взаємодіє з об'єктами через інтерфейс `Target`.

Слайд 5: Типи адаптерів
 Об’єктний адаптер: Використовує композицію для зв’язку з `Adaptee` (найбільш поширений).
 Класовий адаптер: Використовує множинне успадкування (застосовується рідше, неможливий у Java).

Слайд 6: Код без адаптера (Java)
 Клієнт напряму залежить від старого інтерфейсу `OldPrinter`, що обмежує гнучкість.

    ```java
    class OldPrinter {
        void printOldFormat(String text) {
            System.out.println("Old format: " + text);
        }
    }

    class Client {
        void printDocument(String text) {
            OldPrinter printer = new OldPrinter();
            printer.printOldFormat(text); // Прямий виклик несумісного методу
        }
    }
    ```

Слайд 7: Застосування Adapter (Java)

```java
// 1. Цільовий інтерфейс
interface Printer {
    void print(String text);
}

// 2. Клас, що адаптується (не змінюється)
class OldPrinter {
    void printOldFormat(String text) {
        System.out.println("Old format: " + text);
    }
}

// 3. Адаптер
class PrinterAdapter implements Printer {
    private OldPrinter oldPrinter;

    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }

    @Override
    public void print(String text) {
        oldPrinter.printOldFormat(text); // Делегування виклику
    }
}

// 4. Клієнт
class Client {
    private Printer printer;

    public Client(Printer printer) {
        this.printer = printer;
    }

    void printDocument(String text) {
        printer.print(text); // Робота через уніфікований інтерфейс
    }
}
```

Слайд 8: Переваги після застосування
 Клієнт працює з уніфікованим інтерфейсом `Printer`.
 Легко підключити нові принтери, що реалізують `Printer`.
 Старий код `OldPrinter` залишився незмінним.

Слайд 9: Практичне застосування
 Інтеграція зі старими системами (legacy code).
 Робота з бібліотеками зі несумісними API.
 Забезпечення гнучкості при зміні зовнішніх сервісів.
 Приклад: Адаптація старого API платіжної системи до нового уніфікованого інтерфейсу `PaymentGateway`.

Слайд 10: Висновки
 Патерн Adapter забезпечує сумісність між несумісними інтерфейсами.
 Дозволяє використовувати старий код без змін.
 Покращує модульність і гнучкість системи.
 Застосовується в реальних проєктах для інтеграції та масштабування.

Слайд 11: Дякую за увагу!


Додаток В (приклади програмного коду)

java
// 1. Цільовий інтерфейс
interface Printer {
    void print(String text);
}

// 2. Клас, що адаптується (не змінюється)
class OldPrinter {
    void printOldFormat(String text) {
        System.out.println("Old format: " + text);
    }
}

// 3. Адаптер
class PrinterAdapter implements Printer {
    private OldPrinter oldPrinter;

    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }

    @Override
    public void print(String text) {
        oldPrinter.printOldFormat(text); // Делегування виклику
    }
}

// 4. Клієнт
class Client {
    private Printer printer;

    public Client(Printer printer) {
        this.printer = printer;
    }

    void printDocument(String text) {
        printer.print(text); // Робота через уніфікований інтерфейс
    }
}
